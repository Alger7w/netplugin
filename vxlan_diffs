diff --git a/drivers/ovsdriver.go b/drivers/ovsdriver.go
index 6474451..7740b1d 100644
--- a/drivers/ovsdriver.go
+++ b/drivers/ovsdriver.go
@@ -357,12 +357,11 @@ func (d *OvsDriver) Deinit() {
 
 func (d *OvsDriver) CreateNetwork(id string) error {
     var err error
-    var pktTag uint
+    var extPktTag, pktTag uint
     var subnetLen uint
     var subnetIp string
     var gOper gstate.Oper
 
-	// no-op for a vlan based network, just create oper state
 	cfgNetState := OvsCfgNetworkState{StateDriver: d.stateDriver}
 	err = cfgNetState.Read(id)
 	if err != nil {
@@ -385,6 +384,11 @@ func (d *OvsDriver) CreateNetwork(id string) error {
             if err != nil {
                 return err
             }
+        } else if gOper.DefaultNetType == "vxlan" {
+            extPktTag, pktTag, err = gOper.AllocVxlan()
+            if err != nil {
+                return err
+            }
         }
 
         err = gOper.Update(d.stateDriver)
@@ -392,12 +396,29 @@ func (d *OvsDriver) CreateNetwork(id string) error {
             return err
         }
 
-        log.Printf("allocated vlan %d \n", pktTag)
+        log.Printf("allocated vlan %d vxlan %d \n", pktTag, extPktTag)
+        operNwState.ExtPktTag = int(extPktTag)
         operNwState.PktTag = int(pktTag)
     } else {
-        operNwState.PktTag, err = strconv.Atoi(cfgNetState.PktTag)
-        if err != nil {
-            return err
+        if cfgNetState.PktTagType == "vxlan" {
+            pktTag, err = gOper.AllocLocalVlan()
+            if err != nil {
+                return err
+            }
+
+            err = gOper.Update(d.stateDriver)
+            if err != nil {
+                log.Printf("error updating the global state - %s \n", err)
+                return err
+            }
+
+            operNwState.PktTag = int(pktTag)
+            operNwState.ExtPktTag, err = strconv.Atoi(cfgNetState.PktTag)
+        } else if cfgNetState.PktTagType == "vlan" {
+            operNwState.PktTag, err = strconv.Atoi(cfgNetState.PktTag)
+            if err != nil {
+                return err
+            }
         }
     }
 
@@ -431,9 +452,61 @@ func (d *OvsDriver) CreateNetwork(id string) error {
 }
 
 func (d *OvsDriver) DeleteNetwork(id string) error {
-	// no-op for a vlan based network, just delete oper state
-	operNwState := OvsOperNetworkState{StateDriver: d.stateDriver, Id: id}
-	err := operNwState.Clear()
+    var err error
+    var gOper gstate.Oper
+
+    cfgNetState := OvsCfgNetworkState{StateDriver: d.stateDriver}
+    err = cfgNetState.Read(id)
+    if err != nil {
+        return err
+    }
+    
+    err = gOper.Read(d.stateDriver)
+    if err != nil {
+        return err
+    }
+
+	operNwState := OvsOperNetworkState{StateDriver: d.stateDriver}
+    err = operNwState.Read(id)
+    if err != nil {
+        return err
+    }
+
+    if cfgNetState.PktTag == "auto" {
+        if gOper.DefaultNetType == "vlan" {
+            err = gOper.FreeVlan(uint(operNwState.PktTag))
+            if err != nil {
+                return err
+            }
+        } else if gOper.DefaultNetType == "vxlan" {
+            err = gOper.FreeVxlan(uint(operNwState.ExtPktTag),
+                uint(operNwState.PktTag))
+            if err != nil {
+                return err
+            }
+        }
+
+        err = gOper.Update(d.stateDriver)
+        if err != nil {
+            log.Printf("error updating the global state - %s \n", err)
+            return err
+        }
+    } else {
+        if cfgNetState.PktTagType == "vxlan" {
+            err = gOper.FreeLocalVlan(uint(operNwState.PktTag))
+            if err != nil {
+                return err
+            }
+
+            err = gOper.Update(d.stateDriver)
+            if err != nil {
+                log.Printf("error updating the global state - %s \n", err)
+                return err
+            }
+        } 
+    }
+
+	err = operNwState.Clear()
 	if err != nil {
 		return err
 	}
diff --git a/drivers/ovsnetworkstate.go b/drivers/ovsnetworkstate.go
index 157939e..ce085b1 100644
--- a/drivers/ovsnetworkstate.go
+++ b/drivers/ovsnetworkstate.go
@@ -71,6 +71,7 @@ type OvsOperNetworkState struct {
 	Id          string           `json:"id"`
 	PktTagType  string           `json:"pktTagType"`
 	PktTag      int              `json:"pktTag"`
+    ExtPktTag   int              `json:"extPktTag"`
 	SubnetIp    string           `json:"subnetIp"`
 	SubnetLen   uint             `json:"subnetLen"`
 	DefaultGw   string           `json:"defaultGw"`
diff --git a/gstate/gstate.go b/gstate/gstate.go
index 16be4f4..831822a 100644
--- a/gstate/gstate.go
+++ b/gstate/gstate.go
@@ -68,6 +68,9 @@ type Oper struct {
     AllocSubnetLen      uint
     AllocedSubnets      bitset.BitSet
     FreeVlans           bitset.BitSet
+    FreeLocalVlans      bitset.BitSet
+    FreeVxlansStart     uint
+    FreeVxlans          bitset.BitSet
 }
 
 var gCfg *Cfg
@@ -110,10 +113,8 @@ func (gc *Cfg) checkErrors() error {
         return err
     }
 
-    if gc.Deploy.DefaultNetType == "vxlan" {
-        return errors.New("vxlan support is coming soon... \n")
-    }
-    if gc.Deploy.DefaultNetType != "vlan" {
+    if gc.Deploy.DefaultNetType != "vlan" && 
+        gc.Deploy.DefaultNetType != "vxlan" {
         return errors.New(fmt.Sprintf("unsupported net type %s", 
             gc.Deploy.DefaultNetType))
     }
@@ -186,13 +187,111 @@ func (g *Oper) Read(d core.StateDriver) error {
     return nil
 }
 
+func (g *Oper)initVxlanBitset(vxlans string, vlans string,
+    defPktType string) error {
+    var vxlanRange netutils.TagRange
+
+    g.FreeVxlans = *netutils.CreateBitset(14)
+
+    if defPktType == "vxlan" && vlans == "" {
+        g.FreeLocalVlans = g.FreeVlans
+        g.FreeVlans = *g.FreeVlans.Complement()
+        clearReservedVlans(&g.FreeVlans)
+    } else {
+        g.FreeLocalVlans = *g.FreeVlans.Complement()
+        clearReservedVlans(&g.FreeLocalVlans)
+    }
+
+    if vxlans == "" {
+        vxlanRange.Min = 10000
+        vxlanRange.Max = 26000
+    } else {
+        vxlanRanges, err := netutils.ParseTagRanges(vxlans, "vxlan")
+        if err != nil {
+            return err
+        }
+        vxlanRange = vxlanRanges[0]
+    }
+
+    g.FreeVxlansStart = uint(vxlanRange.Min)
+    for vxlan := vxlanRange.Min; vxlan <= vxlanRange.Max; vxlan++ {
+        g.FreeVxlans.Set(uint(vxlan - vxlanRange.Min))
+    }
+
+    return nil
+}
+
+func (g *Oper)AllocVxlan ()(vxlan uint, localVlan uint, err error) {
+    var ok bool
+
+    vxlan, ok = g.FreeVxlans.NextSet(0)
+    if !ok {
+        err = errors.New("no Vxlans available ")
+        return 
+    }
+
+    localVlan, ok = g.FreeLocalVlans.NextSet(0)
+    if !ok {
+        err = errors.New("no local vlans available ")
+        return 
+    }
+
+    g.FreeVxlans.Set(vxlan)
+    vxlan = vxlan + g.FreeVxlansStart
+
+    return 
+}
+
+func (g *Oper)FreeVxlan (vxlan uint, localVlan uint) error {
+    if !g.FreeLocalVlans.Test(localVlan) {
+        g.FreeLocalVlans.Clear(localVlan)
+    }
+
+    vxlan = vxlan - g.FreeVxlansStart
+    if !g.FreeVxlans.Test(vxlan) {
+        g.FreeVxlans.Clear(vxlan)
+    }
+
+    return nil
+}
+
+func (g *Oper)AllocLocalVlan ()(uint, error) {
+    vlan, ok := g.FreeLocalVlans.NextSet(0)
+    if !ok {
+        return 0, errors.New("no vlans available ")
+    }
+
+    g.FreeLocalVlans.Set(vlan)
+
+    return vlan, nil
+}
+
+// be idempotent, don't complain if vlan is already freed
+func (g *Oper)FreeLocalVlan (vlan uint) error {
+    if !g.FreeLocalVlans.Test(vlan) {
+        g.FreeLocalVlans.Clear(vlan)
+    }
+    return nil
+}
+
+func clearReservedVlans(vlanBitset *bitset.BitSet) {
+    vlanBitset.Clear(0)
+    vlanBitset.Clear(4095)
+}
+
 func (g *Oper)initVlanBitset(vlans string) error {
+
+    g.FreeVlans = *netutils.CreateBitset(12)
+
+    if vlans == "" {
+        vlans = "1-4094"
+    } 
+
     vlanRanges, err := netutils.ParseTagRanges(vlans, "vlan")
     if err != nil {
         return err
     }
 
-    g.FreeVlans.Copy(netutils.CreateBitset(12))
     for _, vlanRange := range vlanRanges {
         for vlan := vlanRange.Min; vlan <= vlanRange.Max; vlan++ {
             g.FreeVlans.Set(uint(vlan))
@@ -244,6 +343,13 @@ func (g *Oper)FreeSubnet(subnetIp string) error {
     return nil
 }
 
+func clearState() (error) {
+    gOper = nil
+    gCfg = nil
+
+    return nil
+}
+
 // process config state and spew out new oper state
 func (gc *Cfg) Process() (*Oper, error) {
     var err error
@@ -270,7 +376,7 @@ func (gc *Cfg) Process() (*Oper, error) {
         
         allocSubnetSize := gc.Auto.AllocSubnetLen - gc.Auto.SubnetLen 
 
-        gOper.AllocedSubnets.Copy(netutils.CreateBitset(allocSubnetSize))
+        gOper.AllocedSubnets = *netutils.CreateBitset(allocSubnetSize)
         gOper.AllocedSubnets.Set( 1 + (1 << allocSubnetSize))
 
         err = gOper.initVlanBitset(gc.Auto.Vlans)
@@ -279,10 +385,15 @@ func (gc *Cfg) Process() (*Oper, error) {
             return nil, err
         }
 
-        log.Printf("created oper state %v \n", gOper)
+        err = gOper.initVxlanBitset(gc.Auto.Vxlans, gc.Auto.Vlans, 
+            gc.Deploy.DefaultNetType)
+        if err != nil {
+            log.Printf("Error '%s' initializing vlans \n", err)
+            return nil, err
+        }
     }
 
-    log.Printf("updating the global config to new state %v \n", gc)
+    // log.Printf("updating the global config to new state %v \n", gc)
     gCfg = gc
 
     return gOper, nil
diff --git a/gstate/gstate_test.go b/gstate/gstate_test.go
index 0407499..38b3a6d 100644
--- a/gstate/gstate_test.go
+++ b/gstate/gstate_test.go
@@ -19,35 +19,260 @@ import (
     "testing"
 )
 
-// specifies parameters that decides the deployment choices
+func TestGlobalConfigAutoVlans(t *testing.T) {
+    cfgData := []byte(`
+        {
+            "Version" : "0.01",
+            "Auto" : {
+                "SubnetPool"        : "11.5.0.0",
+                "SubnetLen"         : 16,
+                "AllocSubnetLen"    : 24,
+                "Vlans"             : "",
+                "Vxlans"            : ""
+            },
+            "Deploy" : {
+                "DefaultNetType"    : "vlan"
+            }
+        }`)
+    var vlan uint
+    var g *Oper
+    defer func() { clearState() }()
+
+    gc, err := Parse(cfgData)
+    if err != nil {
+        t.Fatalf("error '%s' parsing config '%s' \n", err, cfgData)
+    }
+
+    g, err = gc.Process()
+    if err != nil {
+        t.Fatalf("error '%s' processing config %v \n", err, gc)
+    }
 
-func TestGlobalConfig(t *testing.T) {
+    vlan, err = g.AllocVlan()
+    if err != nil {
+        t.Fatalf("error - allocating vlan - %s \n", err)
+    }
+    if vlan == 0 {
+        t.Fatalf("error - invalid vlan id allocated %d \n", vlan)
+    }
+
+    err = g.FreeVlan(vlan)
+    if err != nil {
+        t.Fatalf("error freeing allocated vlan %d - err '%s' \n", vlan ,err)
+    }
+}
+
+func TestGlobalConfigSpecificVlans(t *testing.T) {
     cfgData := []byte(`
         {
-            "Version" : "0.1",
+            "Version" : "0.01",
             "Auto" : {
                 "SubnetPool"        : "11.5.0.0",
                 "SubnetLen"         : 16,
                 "AllocSubnetLen"    : 24,
-                "Vlans"             : "100-400,500-900",
-                "Vxlans"            : "10000-20000"
+                "Vlans"             : "200-300,1000-1500",
+                "Vxlans"            : ""
             },
             "Deploy" : {
                 "DefaultNetType"    : "vlan"
             }
         }`)
+    var vlan uint
+    var g *Oper
+    defer func() { clearState() }()
 
-    _, err := Parse(cfgData)
+    gc, err := Parse(cfgData)
+    if err != nil {
+        t.Fatalf("error '%s' parsing config '%s' \n", err, cfgData)
+    }
+
+    g, err = gc.Process()
+    if err != nil {
+        t.Fatalf("error '%s' processing config %v \n", err, gc)
+    }
+
+    vlan, err = g.AllocVlan()
+    if err != nil {
+        t.Fatalf("error - allocating vlan - %s \n", err)
+    }
+    if vlan != 200 {
+        t.Fatalf("error - expecting vlan %d but allocated %d \n", 200, vlan)
+    }
+
+    err = g.FreeVlan(vlan)
+    if err != nil {
+        t.Fatalf("error freeing allocated vlan %d - err '%s' \n", vlan ,err)
+    }
+}
+
+func TestGlobalConfigAutoVxlan(t *testing.T) {
+    cfgData := []byte(`
+        {
+            "Version" : "0.01",
+            "Auto" : {
+                "SubnetPool"        : "11.5.0.0",
+                "SubnetLen"         : 16,
+                "AllocSubnetLen"    : 24,
+                "Vlans"             : "",
+                "Vxlans"            : ""
+            },
+            "Deploy" : {
+                "DefaultNetType"    : "vxlan"
+            }
+        }`)
+    var vxlan, localVlan uint
+    var g *Oper
+    defer func() { clearState() }()
+
+    gc, err := Parse(cfgData)
+    if err != nil {
+        t.Fatalf("error '%s' parsing config '%s' \n", err, cfgData)
+    }
+
+    g, err = gc.Process()
+    if err != nil {
+        t.Fatalf("error '%s' processing config %v \n", err, gc)
+    }
+
+    vxlan, localVlan, err = g.AllocVxlan()
+    if err != nil {
+        t.Fatalf("error - allocating vxlan - %s \n", err)
+    }
+    if vxlan == 0 {
+        t.Fatalf("error - invalid vxlan allocated %d \n", vxlan)
+    }
+    if localVlan == 0 {
+        t.Fatalf("error - invalid vlan allocated d \n", localVlan)
+    }
+
+    _, err = g.AllocVlan()
+    if err == nil {
+        t.Fatalf("error - was expecting vlan allocation to fail \n")
+    }
+
+    err = g.FreeVxlan(vxlan, localVlan)
+    if err != nil {
+        t.Fatalf("error freeing allocated vxlan %d localvlan %d - err '%s' \n", 
+            vxlan, localVlan ,err)
+    }
+}
+
+func TestGlobalConfigSpecificVxlans(t *testing.T) {
+    cfgData := []byte(`
+        {
+            "Version" : "0.01",
+            "Auto" : {
+                "SubnetPool"        : "11.5.0.0",
+                "SubnetLen"         : 16,
+                "AllocSubnetLen"    : 24,
+                "Vlans"             : "",
+                "Vxlans"            : "11111-15000"
+            },
+            "Deploy" : {
+                "DefaultNetType"    : "vxlan"
+            }
+        }`)
+    var vxlan, localVlan uint
+    var g *Oper
+    defer func() { clearState() }()
+
+    gc, err := Parse(cfgData)
     if err != nil {
         t.Fatalf("error '%s' parsing config '%s' \n", err, cfgData)
     }
+
+    g, err = gc.Process()
+    if err != nil {
+        t.Fatalf("error '%s' processing config %v \n", err, gc)
+    }
+
+    vxlan, localVlan, err = g.AllocVxlan()
+    if err != nil {
+        t.Fatalf("error - allocating vxlan - %s \n", err)
+    }
+    if vxlan != 11111 {
+        t.Fatalf("error - invalid vxlan allocated %d expecting %d\n", vxlan, 11111)
+    }
+    if localVlan == 0 {
+        t.Fatalf("error - invalid vlan allocated d \n", localVlan)
+    }
+
+    _, err = g.AllocVlan()
+    if err == nil {
+        t.Fatalf("error - was expecting vlan allocation to fail \n")
+    }
+
+    err = g.FreeVxlan(vxlan, localVlan)
+    if err != nil {
+        t.Fatalf("error freeing allocated vxlan %d localvlan %d - err '%s' \n", 
+            vxlan, localVlan ,err)
+    }
 }
 
+func TestGlobalConfigDefaultVxlanWithVlans(t *testing.T) {
+    cfgData := []byte(`
+        {
+            "Version" : "0.01",
+            "Auto" : {
+                "SubnetPool"        : "11.5.0.0",
+                "SubnetLen"         : 16,
+                "AllocSubnetLen"    : 24,
+                "Vlans"             : "100-400,500-900",
+                "Vxlans"            : "10000-20000"
+            },
+            "Deploy" : {
+                "DefaultNetType"    : "vxlan"
+            }
+        }`)
+    var vlan, localVlan, vxlan uint
+    var g *Oper
+    defer func() { clearState() }()
+
+    gc, err := Parse(cfgData)
+    if err != nil {
+        t.Fatalf("error '%s' parsing config '%s' \n", err, cfgData)
+    }
+
+    g, err = gc.Process()
+    if err != nil {
+        t.Fatalf("error '%s' processing config %v \n", err, gc)
+    }
+
+    vlan, err = g.AllocVlan()
+    if err != nil {
+        t.Fatalf("error - allocating vlan - %s \n", err)
+    }
+    if vlan != 100 {
+        t.Fatalf("error - expecting vlan %d but allocated %d \n", 100, vlan)
+    }
+
+    vxlan, localVlan, err = g.AllocVxlan()
+    if err != nil {
+        t.Fatalf("error - allocating vxlan - %s \n", err)
+    }
+    if vxlan != 10000 {
+        t.Fatalf("error - expecting vlan %d but allocated %d \n", 10000, vxlan)
+    }
+    if localVlan == 0 {
+        t.Fatalf("error - invalid vlan allocated %d \n", localVlan)
+    }
+
+    err = g.FreeVlan(vlan)
+    if err != nil {
+        t.Fatalf("error freeing allocated vlan %d - err '%s' \n", vlan ,err)
+    }
+
+    err = g.FreeVxlan(vxlan, localVlan)
+    if err != nil {
+        t.Fatalf("error freeing allocated vxlan %d localvlan %d - err '%s' \n", 
+            vxlan, localVlan ,err)
+    }
+}
 
 func TestInvalidGlobalConfig(t *testing.T) {
     cfgData := []byte(`
         {
-            "Version" : "0.1",
+            "Version" : "0.01",
             "Auto" : {
                 "SubnetPool"        : "11..5.0.0",
                 "SubnetLen"         : 16,
@@ -62,17 +287,17 @@ func TestInvalidGlobalConfig(t *testing.T) {
 
     _, err := Parse(cfgData)
     if err == nil {
-        t.Fatalf("parsed invalid data '%s' \n", cfgData)
+        t.Fatalf("Error: was able to parse invalid subnet pool '%s' \n", err, cfgData)
     }
 
     cfgData = []byte(`
         {
-            "Version" : "0.1",
+            "Version" : "0.01",
             "Auto" : {
-                "SubnetPool"        : "11..5.0.0",
+                "SubnetPool"        : "11.5.0.0",
                 "SubnetLen"         : 16,
                 "AllocSubnetLen"    : 24,
-                "Vlans"             : "100-400,500-900",
+                "Vlans"             : "100-400,900-500",
                 "Vxlans"            : "10000-20000"
             },
             "Deploy" : {
@@ -82,14 +307,14 @@ func TestInvalidGlobalConfig(t *testing.T) {
 
     _, err = Parse(cfgData)
     if err == nil {
-        t.Fatalf("parsed invalid data '%s' \n", cfgData)
+        t.Fatalf("Error: was able to parse invalid vlan range '%s' \n", err, cfgData)
     }
 
     cfgData = []byte(`
         {
-            "Version" : "0.1",
+            "Version" : "0.01",
             "Auto" : {
-                "SubnetPool"        : "11..5.0.0",
+                "SubnetPool"        : "11.5.0.0",
                 "SubnetLen"         : 22,
                 "AllocSubnetLen"    : 20,
                 "Vlans"             : "100-400,500-900",
@@ -102,6 +327,8 @@ func TestInvalidGlobalConfig(t *testing.T) {
 
     _, err = Parse(cfgData)
     if err == nil {
-        t.Fatalf("parsed invalid data '%s' \n", cfgData)
+        t.Fatalf("Error: was able to parse invalid subnetlen/allcocsubnetlen %s'\n", 
+            err, cfgData)
     }
+
 }
diff --git a/netd.go b/netd.go
index 9b85c4f..3e92b3c 100644
--- a/netd.go
+++ b/netd.go
@@ -67,10 +67,7 @@ func handleEtcdEvents(netPlugin *plugin.NetPlugin, rsps chan *etcd.Response,
 				if err != nil {
 					log.Printf("error '%s' updating goper state %v \n",
 						err, gOper)
-				} else {
-					log.Printf("Successfully updated global oper state: %v \n",
-						gOper)
-				}
+				} 
 			}
 
 		case strings.HasPrefix(key, drivers.NW_CFG_PATH_PREFIX):
diff --git a/netdcli/netdcli.go b/netdcli/netdcli.go
index ae0bb99..b827a17 100644
--- a/netdcli/netdcli.go
+++ b/netdcli/netdcli.go
@@ -212,22 +212,25 @@ func validateOpts() error {
 		log.Fatalf("A construct must be specified")
 	}
 
+    if opts.pktTagType != "vxlan" && opts.pktTagType != "vlan" {
+        log.Fatalf("error '%s' packet tag type not supported", opts.pktTagType)
+    }
+
     // global create params validation
     if opts.oper.Get() == CLI_OPER_CREATE &&
        opts.construct.Get() == CLI_CONSTRUCT_GLOBAL {
-        if opts.pktTag == "vxlan" {
-            log.Fatalf("default vxlan tunneling support is coming soon...")
-        } else if opts.pktTagType != "vlan" {
-            log.Fatalf("error '%s' packet tag type not supported", opts.pktTagType)
-        } 
-
-        _, err = netutils.ParseTagRanges(opts.vlans, "vlan")
-        if err != nil {
-            log.Fatalf("error '%s' parsing vlan range '%s' \n", err, opts.vlans)
+        if opts.vlans != "" {
+            _, err = netutils.ParseTagRanges(opts.vlans, "vlan")
+            if err != nil {
+                log.Fatalf("error '%s' parsing vlan range '%s' \n", err, opts.vlans)
+            }
         }
-        _, err = netutils.ParseTagRanges(opts.vxlans, "vxlan")
-        if err != nil {
-            log.Fatalf("error '%s' parsing vxlan range '%s' \n", err, opts.vxlans)
+
+        if opts.vxlans != "" {
+            _, err = netutils.ParseTagRanges(opts.vxlans, "vxlan")
+            if err != nil {
+                log.Fatalf("error '%s' parsing vxlan range '%s' \n", err, opts.vxlans)
+            }
         }
     }
 
@@ -243,12 +246,6 @@ func validateOpts() error {
         }
     }
 
-    if opts.pktTagType == "vxlan" {
-        log.Fatalf("vxlan tunneling support is coming soon...")
-    } else if opts.pktTagType != "vlan" {
-        log.Fatalf("error '%s' packet tag type not supported", opts.pktTagType)
-    } 
-
     // network create params validation
 	if opts.oper.Get() == CLI_OPER_CREATE &&
        opts.construct.Get() == CLI_CONSTRUCT_NW {
diff --git a/netutils/netutils.go b/netutils/netutils.go
index fa79f40..27cded0 100644
--- a/netutils/netutils.go
+++ b/netutils/netutils.go
@@ -163,6 +163,11 @@ func ParseTagRanges(ranges string, tagType string) ([]TagRange, error) {
         return nil, errors.New(fmt.Sprintf("invalid tag type %s ", tagType))
     }
     rangesStr := strings.Split(ranges, ",")
+
+    if len(rangesStr) > 1 && tagType == "vxlan" {
+        return nil, errors.New("do not support more than 2 vxlan tag ranges")
+    }
+
     tagRanges := make([]TagRange, len(rangesStr), len(rangesStr))
     for idx, oneRangeStr := range rangesStr {
         oneRangeStr = strings.Trim(oneRangeStr, " ")
@@ -194,6 +199,12 @@ func ParseTagRanges(ranges string, tagType string) ([]TagRange, error) {
             return nil, errors.New(fmt.Sprintf(
                 "invalid range %s, vlan values exceed 65535 max allowed", oneRangeStr))
         }
+        if tagType == "vxlan" && 
+            (tagRanges[idx].Max - tagRanges[idx].Min > 16000) {
+            return nil, errors.New(fmt.Sprintf(
+                "does not allow vxlan range to exceed 16000 range %s", 
+                oneRangeStr))
+        }
     }
 
     return tagRanges, nil
diff --git a/netutils/netutils_test.go b/netutils/netutils_test.go
index d45dff4..c972fa0 100644
--- a/netutils/netutils_test.go
+++ b/netutils/netutils_test.go
@@ -116,8 +116,24 @@ func TestInvalidRangeExtraSeperators (t *testing.T) {
     }
 }
 
-func TestInvalidVlanVxlanValue(t *testing.T) {
-    rangeStr := "5-100, 101-75535"
+func TestValidVxlanRange(t *testing.T) {
+    rangeStr := "10000-16000"
+    _, err := ParseTagRanges(rangeStr, "vxlan")
+    if err != nil {
+        t.Fatalf("error '%s' parsing valid vxlan range '%s'\n", err, rangeStr)
+    }
+}
+
+func TestInvalidVxlanMultipleRanges(t *testing.T) {
+    rangeStr := "101-400, 10000-15000"
+    _, err := ParseTagRanges(rangeStr, "vxlan")
+    if err == nil {
+        t.Fatalf("successfully parsed invalid vxlan value '%s'\n", rangeStr)
+    }
+}
+
+func TestInvalidVxlanValue(t *testing.T) {
+    rangeStr := "101-75535"
     _, err := ParseTagRanges(rangeStr, "vxlan")
     if err == nil {
         t.Fatalf("successfully parsed invalid vxlan value '%s'\n", rangeStr)
@@ -125,7 +141,7 @@ func TestInvalidVlanVxlanValue(t *testing.T) {
 }
 
 func TestInvalidMinMaxVxlan(t *testing.T) {
-    rangeStr := "5-100, 8000-7999"
+    rangeStr := "8000-7999"
     _, err := ParseTagRanges(rangeStr, "vxlan")
     if err == nil {
         t.Fatalf("successfully parsed invalid min-max vxlan values '%s'\n", rangeStr)
@@ -180,4 +196,3 @@ func TestGetSubnetNumber(t *testing.T) {
         }
     }
 }
-
